"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatisticsLogger = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
/**
 * –õ–æ–≥–≥–µ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ç–æ—Ä–≥–æ–≤–ª–∏
 */
class StatisticsLogger {
    logger;
    statsFile;
    dailyStatsFile;
    constructor(logger) {
        this.logger = logger;
        this.statsFile = './logs/trading-stats.json';
        this.dailyStatsFile = './logs/daily-stats.json';
        // –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        const logDir = path_1.default.dirname(this.statsFile);
        if (!fs_1.default.existsSync(logDir)) {
            fs_1.default.mkdirSync(logDir, { recursive: true });
        }
    }
    /**
     * –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—É—é —Å–¥–µ–ª–∫—É
     */
    logTrade(trade) {
        const tradeInfo = {
            ...trade,
            timestamp: new Date(trade.timestamp).toISOString(),
            duration: this.formatDuration(trade.duration),
            pnlFormatted: `${trade.pnl >= 0 ? '+' : ''}${trade.pnl.toFixed(4)} USDT`,
            pnlPercentFormatted: `${trade.pnlPercent >= 0 ? '+' : ''}${trade.pnlPercent.toFixed(2)}%`
        };
        // –õ–æ–≥–∏—Ä—É–µ–º –≤ –∫–æ–Ω—Å–æ–ª—å
        const emoji = trade.pnl >= 0 ? '‚úÖ' : '‚ùå';
        this.logger.info(tradeInfo, `${emoji} –°–¥–µ–ª–∫–∞ ${trade.side.toUpperCase()} ${trade.symbol}: ${tradeInfo.pnlFormatted} (${tradeInfo.pnlPercentFormatted})`);
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª
        this.saveTradeToFile(trade);
    }
    /**
     * –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
     */
    logPeriodic(botStats) {
        const stats = botStats.performance;
        const risk = botStats.risk;
        const summary = {
            timestamp: new Date().toISOString(),
            dailyPnL: `${risk.dailyPnL >= 0 ? '+' : ''}${risk.dailyPnL.toFixed(2)} USDT`,
            totalTrades: stats.totalTrades,
            winRate: `${stats.winRate.toFixed(1)}%`,
            profitFactor: stats.profitFactor.toFixed(2),
            maxDrawdown: `${stats.maxDrawdown.toFixed(2)}%`,
            activePositions: botStats.positions.totalPositions,
            avgTradeDuration: this.formatDuration(botStats.positions.avgDuration)
        };
        this.logger.info(summary, 'üìä –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞');
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–Ω–µ–≤–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        this.saveDailyStats(risk, stats);
    }
    /**
     * –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏
     */
    logPositionOpen(position) {
        const positionValue = position.quantity * position.entryPrice;
        const tpDistance = Math.abs((position.takeProfit - position.entryPrice) / position.entryPrice * 100);
        const slDistance = Math.abs((position.stopLoss - position.entryPrice) / position.entryPrice * 100);
        this.logger.info({
            position: {
                ...position,
                value: `${positionValue.toFixed(2)} USDT`,
                tpDistance: `${tpDistance.toFixed(2)}%`,
                slDistance: `${slDistance.toFixed(2)}%`
            }
        }, `üîì –û—Ç–∫—Ä—ã—Ç–∞ –ø–æ–∑–∏—Ü–∏—è ${position.side.toUpperCase()} ${position.symbol}`);
    }
    /**
     * –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏ —Ç–æ—Ä–≥–æ–≤–ª–∏
     */
    logTradingError(error) {
        this.logger.error({
            error: {
                ...error,
                timestamp: new Date().toISOString()
            }
        }, `‚ùå –û—à–∏–±–∫–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏: ${error.message}`);
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª
        if (error.type === 'api_error' || error.type === 'websocket_error') {
            this.saveErrorToFile(error);
        }
    }
    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á–µ—Ç –∑–∞ –¥–µ–Ω—å
     */
    generateDailyReport() {
        try {
            const today = new Date().toISOString().split('T')[0];
            const dailyStats = this.loadDailyStats();
            const todayStats = dailyStats.find(s => s.date === today);
            if (!todayStats) {
                return 'üìä –î–∞–Ω–Ω—ã—Ö –∑–∞ —Å–µ–≥–æ–¥–Ω—è –ø–æ–∫–∞ –Ω–µ—Ç';
            }
            return `
üìä –î–Ω–µ–≤–Ω–æ–π –æ—Ç—á–µ—Ç (${today}):
‚îú‚îÄ –°–¥–µ–ª–æ–∫: ${todayStats.trades}
‚îú‚îÄ –ü—Ä–∏–±—ã–ª—å: ${todayStats.profit >= 0 ? '+' : ''}${todayStats.profit.toFixed(2)} USDT
‚îú‚îÄ –í–∏–Ω—Ä–µ–π—Ç: ${todayStats.winRate.toFixed(1)}%
‚îú‚îÄ –ú–∞–∫—Å. –ø—Ä–æ—Å–∞–¥–∫–∞: ${todayStats.maxDrawdown.toFixed(2)}%
‚îî‚îÄ –û–±—ä–µ–º: ${todayStats.volume.toFixed(2)} USDT
      `.trim();
        }
        catch (error) {
            this.logger.error({ error }, '–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–Ω–µ–≤–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞');
            return '‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞';
        }
    }
    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á–µ—Ç –ø–æ —Ç–æ—Ä–≥–æ–≤—ã–º –ø–∞—Ä–∞–º
     */
    generatePairReport() {
        try {
            const pairStats = this.calculatePairStats();
            if (pairStats.length === 0) {
                return 'üìä –î–∞–Ω–Ω—ã—Ö –ø–æ —Ç–æ—Ä–≥–æ–≤—ã–º –ø–∞—Ä–∞–º –Ω–µ—Ç';
            }
            let report = 'üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–∞—Ä–∞–º:\n';
            pairStats.forEach((pair, index) => {
                const connector = index === pairStats.length - 1 ? '‚îî‚îÄ' : '‚îú‚îÄ';
                report += `${connector} ${pair.symbol}: ${pair.trades} —Å–¥–µ–ª–æ–∫, `;
                report += `${pair.profit >= 0 ? '+' : ''}${pair.profit.toFixed(2)} USDT `;
                report += `(${pair.winRate.toFixed(1)}%)\n`;
            });
            return report.trim();
        }
        catch (error) {
            this.logger.error({ error }, '–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞ –ø–æ –ø–∞—Ä–∞–º');
            return '‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞';
        }
    }
    /**
     * –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–æ—Ä–≥–æ–≤–ª–∏
     */
    calculateTradeStatistics() {
        try {
            const trades = this.loadTradesFromFile();
            if (trades.length === 0) {
                return this.getEmptyStats();
            }
            const winningTrades = trades.filter(t => t.pnl > 0);
            const losingTrades = trades.filter(t => t.pnl < 0);
            const totalProfit = winningTrades.reduce((sum, t) => sum + t.pnl, 0);
            const totalLoss = Math.abs(losingTrades.reduce((sum, t) => sum + t.pnl, 0));
            const avgTradeDuration = trades.reduce((sum, t) => sum + t.duration, 0) / trades.length;
            const avgTradesPerDay = this.calculateAvgTradesPerDay(trades);
            return {
                totalTrades: trades.length,
                winningTrades: winningTrades.length,
                losingTrades: losingTrades.length,
                winRate: (winningTrades.length / trades.length) * 100,
                avgWin: winningTrades.length > 0 ? totalProfit / winningTrades.length : 0,
                avgLoss: losingTrades.length > 0 ? totalLoss / losingTrades.length : 0,
                totalProfit,
                totalLoss,
                netProfit: totalProfit - totalLoss,
                profitFactor: totalLoss > 0 ? totalProfit / totalLoss : 0,
                maxDrawdown: this.calculateMaxDrawdown(trades),
                avgTradeDuration,
                avgTradesPerDay,
                bestTrade: Math.max(...trades.map(t => t.pnl)),
                worstTrade: Math.min(...trades.map(t => t.pnl)),
                consecutiveWins: this.calculateConsecutiveWins(trades),
                consecutiveLosses: this.calculateConsecutiveLosses(trades),
                sharpeRatio: this.calculateSharpeRatio(trades)
            };
        }
        catch (error) {
            this.logger.error({ error }, '–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏');
            return this.getEmptyStats();
        }
    }
    saveTradeToFile(trade) {
        try {
            const trades = this.loadTradesFromFile();
            trades.push(trade);
            // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 1000 —Å–¥–µ–ª–æ–∫
            if (trades.length > 1000) {
                trades.splice(0, trades.length - 1000);
            }
            fs_1.default.writeFileSync(this.statsFile, JSON.stringify(trades, null, 2));
        }
        catch (error) {
            this.logger.error({ error }, '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏ –≤ —Ñ–∞–π–ª');
        }
    }
    saveDailyStats(riskMetrics, performance) {
        try {
            const today = new Date().toISOString().split('T')[0];
            const dailyStats = this.loadDailyStats();
            const todayIndex = dailyStats.findIndex(s => s.date === today);
            const todayStatsEntry = {
                date: today,
                trades: performance.totalTrades,
                profit: riskMetrics.dailyPnL,
                winRate: performance.winRate,
                maxDrawdown: performance.maxDrawdown,
                volume: 0 // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–¥—Å—á–µ—Ç –æ–±—ä–µ–º–∞
            };
            if (todayIndex >= 0) {
                dailyStats[todayIndex] = todayStatsEntry;
            }
            else {
                dailyStats.push(todayStatsEntry);
            }
            // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π
            if (dailyStats.length > 30) {
                dailyStats.splice(0, dailyStats.length - 30);
            }
            fs_1.default.writeFileSync(this.dailyStatsFile, JSON.stringify(dailyStats, null, 2));
        }
        catch (error) {
            this.logger.error({ error }, '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–Ω–µ–≤–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏');
        }
    }
    saveErrorToFile(error) {
        try {
            const errorFile = './logs/errors.json';
            let errors = [];
            if (fs_1.default.existsSync(errorFile)) {
                errors = JSON.parse(fs_1.default.readFileSync(errorFile, 'utf-8'));
            }
            errors.push({
                ...error,
                timestamp: new Date().toISOString()
            });
            // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 –æ—à–∏–±–æ–∫
            if (errors.length > 100) {
                errors.splice(0, errors.length - 100);
            }
            fs_1.default.writeFileSync(errorFile, JSON.stringify(errors, null, 2));
        }
        catch (err) {
            this.logger.error({ err }, '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –æ—à–∏–±–∫–∏ –≤ —Ñ–∞–π–ª');
        }
    }
    loadTradesFromFile() {
        try {
            if (fs_1.default.existsSync(this.statsFile)) {
                return JSON.parse(fs_1.default.readFileSync(this.statsFile, 'utf-8'));
            }
        }
        catch (error) {
            this.logger.error({ error }, '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–¥–µ–ª–æ–∫ –∏–∑ —Ñ–∞–π–ª–∞');
        }
        return [];
    }
    loadDailyStats() {
        try {
            if (fs_1.default.existsSync(this.dailyStatsFile)) {
                return JSON.parse(fs_1.default.readFileSync(this.dailyStatsFile, 'utf-8'));
            }
        }
        catch (error) {
            this.logger.error({ error }, '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–Ω–µ–≤–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏');
        }
        return [];
    }
    calculatePairStats() {
        const trades = this.loadTradesFromFile();
        const pairMap = new Map();
        // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Å–¥–µ–ª–∫–∏ –ø–æ —Å–∏–º–≤–æ–ª–∞–º
        trades.forEach(trade => {
            if (!pairMap.has(trade.symbol)) {
                pairMap.set(trade.symbol, []);
            }
            pairMap.get(trade.symbol).push(trade);
        });
        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã
        const pairStats = [];
        pairMap.forEach((pairTrades, symbol) => {
            const profit = pairTrades.reduce((sum, t) => sum + t.pnl, 0);
            const winningTrades = pairTrades.filter(t => t.pnl > 0).length;
            const winRate = (winningTrades / pairTrades.length) * 100;
            const lastTradeTime = Math.max(...pairTrades.map(t => t.timestamp));
            pairStats.push({
                symbol,
                trades: pairTrades.length,
                profit,
                winRate,
                avgProfit: profit / pairTrades.length,
                lastTradeTime
            });
        });
        return pairStats.sort((a, b) => b.profit - a.profit);
    }
    formatDuration(ms) {
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        if (hours > 0) {
            return `${hours}—á ${minutes % 60}–º`;
        }
        else if (minutes > 0) {
            return `${minutes}–º ${seconds % 60}—Å`;
        }
        else {
            return `${seconds}—Å`;
        }
    }
    getEmptyStats() {
        return {
            totalTrades: 0,
            winningTrades: 0,
            losingTrades: 0,
            winRate: 0,
            avgWin: 0,
            avgLoss: 0,
            totalProfit: 0,
            totalLoss: 0,
            netProfit: 0,
            profitFactor: 0,
            maxDrawdown: 0,
            avgTradeDuration: 0,
            avgTradesPerDay: 0,
            bestTrade: 0,
            worstTrade: 0,
            consecutiveWins: 0,
            consecutiveLosses: 0,
            sharpeRatio: 0
        };
    }
    calculateMaxDrawdown(trades) {
        let peak = 0;
        let currentPnL = 0;
        let maxDD = 0;
        trades.forEach(trade => {
            currentPnL += trade.pnl;
            if (currentPnL > peak) {
                peak = currentPnL;
            }
            const drawdown = peak - currentPnL;
            if (drawdown > maxDD) {
                maxDD = drawdown;
            }
        });
        return maxDD;
    }
    calculateConsecutiveWins(trades) {
        let maxWins = 0;
        let currentWins = 0;
        trades.forEach(trade => {
            if (trade.pnl > 0) {
                currentWins++;
                maxWins = Math.max(maxWins, currentWins);
            }
            else {
                currentWins = 0;
            }
        });
        return maxWins;
    }
    calculateConsecutiveLosses(trades) {
        let maxLosses = 0;
        let currentLosses = 0;
        trades.forEach(trade => {
            if (trade.pnl < 0) {
                currentLosses++;
                maxLosses = Math.max(maxLosses, currentLosses);
            }
            else {
                currentLosses = 0;
            }
        });
        return maxLosses;
    }
    calculateSharpeRatio(trades) {
        if (trades.length < 2)
            return 0;
        const returns = trades.map(t => t.pnlPercent);
        const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
        const stdDev = Math.sqrt(variance);
        return stdDev > 0 ? avgReturn / stdDev : 0;
    }
    calculateAvgTradesPerDay(trades) {
        if (trades.length === 0)
            return 0;
        const firstTrade = Math.min(...trades.map(t => t.timestamp));
        const lastTrade = Math.max(...trades.map(t => t.timestamp));
        const daysSpan = (lastTrade - firstTrade) / (1000 * 60 * 60 * 24);
        return daysSpan > 0 ? trades.length / daysSpan : 0;
    }
}
exports.StatisticsLogger = StatisticsLogger;
//# sourceMappingURL=statistics.js.map